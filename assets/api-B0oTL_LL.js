const n=await(await import("./kissfft-BPMCP-KH.js")).default(),d=0,g=Float32Array.BYTES_PER_ELEMENT;class _{dataPointer=d;dataLength=0;get pointer(){return this.dataPointer}free(){n._free(this.dataPointer),this.dataPointer=d}get valid(){return this.dataPointer!==0}asFloat32Array(){const t=this.dataPointer/g;return n.HEAPF32.subarray(t,t+this.dataLength)}toFloat32Array(){return new Float32Array(this.asFloat32Array())}}class c extends _{constructor(t){super(),typeof t=="number"?(this.dataLength=t,this.dataPointer=n._allocate(this.dataLength)):(this.dataLength=t.dataLength,this.dataPointer=n._copy(t.pointer,this.dataLength))}get length(){return this.dataLength}static fromDataArray(t){return c.fromArray(t)}static fromArray(t){const e=new c(t.length);return n.HEAPF32.set(t,e.dataPointer/g),e}}class a extends _{constructor(t){super(),typeof t=="number"?(this.dataLength=2*t,this.dataPointer=n._allocate(this.dataLength)):(this.dataLength=t.dataLength,this.dataPointer=n._copy(t.pointer,this.dataLength))}get length(){return this.dataLength/2}realAt(t){return n._get_value(this.dataPointer,t*2)}imagAt(t){return n._get_value(this.dataPointer,t*2+1)}valueAt(t){return{real:this.realAt(t),imag:this.imagAt(t)}}static fromDataArray(t){if(t.length%2===1)throw new Error("Array length must be even.");const e=new a(t.length/2);return n.HEAPF32.set(t,e.dataPointer/g),e}static fromArray(t,e){const i=t.length;if(e!==void 0&&i!==e.length)throw new Error(`Inconsistent length of arguments: real=${i} - imag=${e.length}`);const o=new a(i);for(let s=0;s<i;++s)n._set_value(o.dataPointer,s*2,t[s]);if(e!==void 0)for(let s=0;s<i;++s)n._set_value(o.dataPointer,s*2+1,e[s]);return o}toRealArray(){return Float32Array.from({length:this.length}).map((t,e)=>this.realAt(e))}toImagArray(){return Float32Array.from({length:this.length}).map((t,e)=>this.imagAt(e))}}class l{nfft;inverse;constructor(t,e){this.nfft=t,this.inverse=e}get valid(){return this.pointer!==0}check(t,e){if(t.length!==this.nfft||e.length!==this.nfft)throw new Error("Input or Output length is inconsistent to Config length.")}}class p extends l{ptr=0;constructor(t,e){super(t,e),this.ptr=n._kiss_fft_alloc(t,e,0,0)}get pointer(){return this.ptr}free(){n._free(this.ptr),this.ptr=0}work(t,e){this.check(t,e),n._kiss_fft(this.ptr,t.pointer,e.pointer),this.inverse&&n._scale(e.pointer,this.nfft*2,1/this.nfft)}}class E extends l{dims;ptr=0;constructor(t,e){super(t.reduce((s,f)=>s*f),e),this.dims=t;const i=t.length,o=n._malloc(Int32Array.BYTES_PER_ELEMENT*i);t.forEach((s,f)=>{n.HEAP32[o/Int32Array.BYTES_PER_ELEMENT+f]=s}),this.ptr=n._kiss_fftnd_alloc(o,i,e,0,0),n._free(o)}get pointer(){return this.ptr}free(){n._free(this.ptr),this.ptr=0}work(t,e){this.check(t,e),n._kiss_fftnd(this.ptr,t.pointer,e.pointer),this.inverse&&n._scale(e.pointer,this.nfft*2,1/this.nfft)}}function F(r){if(r%2===1)throw new Error("Real FFT optimization must be even.")}class m extends l{ptr=0;constructor(t,e){super(t,e),F(t),this.ptr=n._kiss_fftr_alloc(t,e,0,0)}get pointer(){return this.ptr}free(){n._free(this.ptr),this.ptr=0}}class k extends m{constructor(t){super(t,!1)}work(t,e){this.check(t,e),n._kiss_fftr(this.ptr,t.pointer,e.pointer)}}class T extends m{constructor(t){super(t,!0)}work(t,e){this.check(t,e),n._kiss_fftri(this.ptr,t.pointer,e.pointer),n._scale(e.pointer,this.nfft,1/this.nfft)}}class w extends l{dims;ptr=0;constructor(t,e){super(t.reduce((s,f)=>s*f),e),this.dims=t;const i=t.length;F(t[i-1]);const o=n._malloc(Int32Array.BYTES_PER_ELEMENT*i);t.forEach((s,f)=>{n.HEAP32[o/Int32Array.BYTES_PER_ELEMENT+f]=s}),this.ptr=n._kiss_fftndr_alloc(o,i,e,0,0),n._free(o)}get pointer(){return this.ptr}free(){n._free(this.ptr),this.ptr=0}}class y extends w{constructor(t){super(t,!1)}work(t,e){this.check(t,e),n._kiss_fftndr(this.ptr,t.pointer,e.pointer)}}class A extends w{constructor(t){super(t,!0)}work(t,e){this.check(t,e),n._kiss_fftndri(this.ptr,t.pointer,e.pointer),n._scale(e.pointer,this.nfft,1/this.nfft)}}function h(r,t,e,i){const o=t.fromDataArray(i),s=new e(o.length);r.work(o,s);const f=s.toFloat32Array();for(const P of[r,o,s])P.free();return f}function u(r,t){return typeof r=="number"?Array.from({length:t.length-1}).map((e,i)=>t[i+1]):r}function D(r){return h(new p(r.length/2,!1),a,a,r)}function x(r){return h(new p(r.length/2,!0),a,a,r)}function N(r,t,e){return L(r,t,e)}function L(r,t){const e=u(t,arguments);return h(new E(e,!1),a,a,r)}function I(r,t,e){return R(r,t,e)}function R(r,t){const e=u(t,arguments);return h(new E(e,!0),a,a,r)}function C(r){return h(new k(r.length),c,a,r)}function b(r){return h(new T(r.length/2),a,c,r)}function B(r,t,e){return v(r,t,e)}function v(r,t){const e=u(t,arguments);return h(new y(e),c,a,r)}function M(r,t,e){return h(new A([t,e]),a,c,r)}function S(r,t){const e=u(t,arguments);return h(new A(e),a,c,r)}export{D as fft,N as fft2d,L as fftnd,x as ifft,I as ifft2d,R as ifftnd,b as irfft,M as irfft2d,S as irfftnd,C as rfft,B as rfft2d,v as rfftnd};
